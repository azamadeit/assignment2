// Задача 3. Сортировка выбором (Selection Sort)
// заголовок задачи
// Последовательная и параллельная (OpenMP) версии
#include <iostream>                                                       // ввод/вывод
#include <vector>                                                         // std::vector
#include <random>                                                         // генерация случайных чисел
#include <chrono>                                                         // измерение времени
#include <algorithm>                                                      // std::swap, std::is_sorted
#include <omp.h>                                                          // OpenMP

using namespace std;                                                      // чтобы не писать std::
using namespace chrono;                                                   // чтобы не писать chrono::

// -------------------- Последовательная сортировка выбором --------------------
// секция seq
static void selection_sort_seq(vector<int>& a)                            // функция последовательной сортировки
{                                                                         // начало функции
    const int n = (int)a.size();                                          // размер массива
    for (int i = 0; i < n - 1; ++i)                                       // внешний цикл — позиция, куда ставим минимум
    {                                                                     // начало внешнего цикла
        int min_idx = i;                                                  // индекс текущего минимума
        for (int j = i + 1; j < n; ++j)                                   // ищем минимум в правой части
        {                                                                 // начало внутреннего цикла
            if (a[j] < a[min_idx])                                        // если нашли меньший элемент
                min_idx = j;                                              // запоминаем новый минимум
        }                                                                 // конец внутреннего цикла
        swap(a[i], a[min_idx]);                                           // ставим найденный минимум на позицию i
    }                                                                     // конец внешнего цикла
}                                                                         // конец функции

// -------------------- OpenMP сортировка выбором --------------------
// секция omp
// Идея: внешний цикл остаётся последовательным,
// объяснение
// а поиск минимума на каждом шаге (внутренний цикл) делаем параллельно.
// объяснение
static void selection_sort_omp(vector<int>& a)                             // функция параллельной сортировки
{                                                                         // начало функции
    const int n = (int)a.size();                                          // размер массива
    for (int i = 0; i < n - 1; ++i)                                       // внешний цикл — зависимый, поэтому seq
    {                                                                     // начало внешнего цикла
        int min_idx = i;                                                  // глобальный индекс минимума
        int min_val = a[i];                                               // глобальное значение минимума

#pragma omp parallel                                                       // запускаем параллельную область
        {                                                                 // начало параллельной области
            int local_idx = min_idx;                                      // локальный индекс минимума у потока
            int local_val = min_val;                                      // локальное значение минимума у потока
#pragma omp for nowait                                                     // делим внутренний цикл между потоками, без барьера
            for (int j = i + 1; j < n; ++j)                               // каждый поток проверяет свою часть диапазона
            {                                                             // начало цикла
                if (a[j] < local_val)                                     // если нашли локально меньший
                {                                                         // начало if
                    local_val = a[j];                                     // обновляем локальный минимум
                    local_idx = j;                                        // обновляем локальный индекс
                }                                                         // конец if
            }                                                             // конец цикла

#pragma omp critical                                                       // аккуратно объединяем локальные минимумы в общий
            {                                                             // начало critical
                if (local_val < min_val)                                  // если локальный минимум меньше глобального
                {                                                         // начало if
                    min_val = local_val;                                  // обновляем глобальное значение
                    min_idx = local_idx;                                  // обновляем глобальный индекс
                }                                                         // конец if
            }                                                             // конец critical
        }                                                                 // конец параллельной области

        swap(a[i], a[min_idx]);                                           // ставим минимум на позицию i
    }                                                                     // конец внешнего цикла
}                                                                         // конец функции

// -------------------- Генерация массива --------------------
// секция генерации
static vector<int> make_random_array(int n, int seed)                     // создаёт массив случайных чисел
{                                                                         // начало функции
    vector<int> a(n);                                                     // выделяем память под n элементов
    mt19937 gen(seed);                                                    // фиксированный seed — одинаковые данные для сравнения
    uniform_int_distribution<int> dis(1, 100000);                         // диапазон значений как в твоих примерах
    for (int i = 0; i < n; ++i)                                           // заполняем массив
        a[i] = dis(gen);                                                  // присваиваем случайное значение
    return a;                                                             // возвращаем массив
}                                                                         // конец функции

// -------------------- Замер времени в миллисекундах --------------------
// секция тайминга
template <typename Func>                                                  // шаблон для замера любой функции сортировки
static long long time_ms(Func f, vector<int> a)                           // принимаем функцию и копию массива
{                                                                         // начало функции
    volatile int warm = 0;                                                // прогрев, чтобы уменьшить шум от кэшей/первого запуска
    for (int i = 0; i < (int)a.size(); ++i) warm += a[i];                 // “трогаем” данные

    auto t1 = high_resolution_clock::now();                               // старт таймера
    f(a);                                                                 // запускаем сортировку
    auto t2 = high_resolution_clock::now();                               // конец таймера

    if (!is_sorted(a.begin(), a.end()))                                   // проверяем корректность сортировки
        cerr << "Sort error!\n";                                          // если не отсортировано — сообщаем

    return duration_cast<milliseconds>(t2 - t1).count();                  // возвращаем время в миллисекундах
}                                                                         // конец функции

// -------------------- Прогон для одного размера --------------------
// секция запуска
static void run_case(int n)                                               // запускает замеры для размера n
{                                                                         // начало функции
    vector<int> base = make_random_array(n, 12345);                       // исходные данные (одинаковые для seq/omp)

    long long t_seq = time_ms(                                            // замеряем seq
        [](vector<int>& x) { selection_sort_seq(x); },                    // передаём seq сортировку
        base                                                             // массив-основа
    );                                                                    // конец вызова

    long long t_par = time_ms(                                            // замеряем omp
        [](vector<int>& x) { selection_sort_omp(x); },                    // передаём omp сортировку
        base                                                             // массив-основа
    );                                                                    // конец вызова

    cout << "Array size: " << n << "\n";                                  // формат вывода как в примере
    cout << "Sequential time: " << t_seq << " ms\n";                      // время последовательной версии
    cout << "Parallel time: " << t_par << " ms\n\n";                      // время параллельной версии + пустая строка
}                                                                         // конец функции

int main()                                                                // main
{                                                                         // начало main
    run_case(1000);                                                       // прогон для 1000
    run_case(10000);                                                      // прогон для 10000
    return 0;                                                             // успешное завершение
}                                                                         // конец main
