// Задача 3. Сортировка выбором (Selection Sort)                         // Комментарий: заголовок задачи
// Последовательная и параллельная (OpenMP) версии                         // Комментарий: что именно реализуем

#include <iostream>                                                       // Комментарий: ввод/вывод
#include <vector>                                                         // Комментарий: std::vector
#include <random>                                                         // Комментарий: генерация случайных чисел
#include <chrono>                                                         // Комментарий: измерение времени
#include <algorithm>                                                      // Комментарий: std::swap, std::is_sorted
#include <omp.h>                                                          // Комментарий: OpenMP

using namespace std;                                                      // Комментарий: чтобы не писать std::
using namespace chrono;                                                   // Комментарий: чтобы не писать chrono::

// -------------------- Последовательная сортировка выбором -------------------- // Комментарий: секция seq
static void selection_sort_seq(vector<int>& a)                            // Комментарий: функция последовательной сортировки
{                                                                         // Комментарий: начало функции
    const int n = (int)a.size();                                          // Комментарий: размер массива
    for (int i = 0; i < n - 1; ++i)                                       // Комментарий: внешний цикл — позиция, куда ставим минимум
    {                                                                     // Комментарий: начало внешнего цикла
        int min_idx = i;                                                  // Комментарий: индекс текущего минимума
        for (int j = i + 1; j < n; ++j)                                   // Комментарий: ищем минимум в правой части
        {                                                                 // Комментарий: начало внутреннего цикла
            if (a[j] < a[min_idx])                                        // Комментарий: если нашли меньший элемент
                min_idx = j;                                              // Комментарий: запоминаем новый минимум
        }                                                                 // Комментарий: конец внутреннего цикла
        swap(a[i], a[min_idx]);                                           // Комментарий: ставим найденный минимум на позицию i
    }                                                                     // Комментарий: конец внешнего цикла
}                                                                         // Комментарий: конец функции

// -------------------- OpenMP сортировка выбором --------------------          // Комментарий: секция omp
// Идея: внешний цикл остаётся последовательным,                              // Комментарий: объяснение
// а поиск минимума на каждом шаге (внутренний цикл) делаем параллельно.       // Комментарий: объяснение
static void selection_sort_omp(vector<int>& a)                             // Комментарий: функция параллельной сортировки
{                                                                         // Комментарий: начало функции
    const int n = (int)a.size();                                          // Комментарий: размер массива
    for (int i = 0; i < n - 1; ++i)                                       // Комментарий: внешний цикл — зависимый, поэтому seq
    {                                                                     // Комментарий: начало внешнего цикла
        int min_idx = i;                                                  // Комментарий: глобальный индекс минимума
        int min_val = a[i];                                               // Комментарий: глобальное значение минимума

#pragma omp parallel                                                       // Комментарий: запускаем параллельную область
        {                                                                 // Комментарий: начало параллельной области
            int local_idx = min_idx;                                      // Комментарий: локальный индекс минимума у потока
            int local_val = min_val;                                      // Комментарий: локальное значение минимума у потока

#pragma omp for nowait                                                     // Комментарий: делим внутренний цикл между потоками, без барьера
            for (int j = i + 1; j < n; ++j)                               // Комментарий: каждый поток проверяет свою часть диапазона
            {                                                             // Комментарий: начало цикла
                if (a[j] < local_val)                                     // Комментарий: если нашли локально меньший
                {                                                         // Комментарий: начало if
                    local_val = a[j];                                     // Комментарий: обновляем локальный минимум
                    local_idx = j;                                        // Комментарий: обновляем локальный индекс
                }                                                         // Комментарий: конец if
            }                                                             // Комментарий: конец цикла

#pragma omp critical                                                       // Комментарий: аккуратно объединяем локальные минимумы в общий
            {                                                             // Комментарий: начало critical
                if (local_val < min_val)                                  // Комментарий: если локальный минимум меньше глобального
                {                                                         // Комментарий: начало if
                    min_val = local_val;                                  // Комментарий: обновляем глобальное значение
                    min_idx = local_idx;                                  // Комментарий: обновляем глобальный индекс
                }                                                         // Комментарий: конец if
            }                                                             // Комментарий: конец critical
        }                                                                 // Комментарий: конец параллельной области

        swap(a[i], a[min_idx]);                                           // Комментарий: ставим минимум на позицию i
    }                                                                     // Комментарий: конец внешнего цикла
}                                                                         // Комментарий: конец функции

// -------------------- Генерация массива --------------------                // Комментарий: секция генерации
static vector<int> make_random_array(int n, int seed)                     // Комментарий: создаёт массив случайных чисел
{                                                                         // Комментарий: начало функции
    vector<int> a(n);                                                     // Комментарий: выделяем память под n элементов
    mt19937 gen(seed);                                                    // Комментарий: фиксированный seed — одинаковые данные для сравнения
    uniform_int_distribution<int> dis(1, 100000);                         // Комментарий: диапазон значений как в твоих примерах
    for (int i = 0; i < n; ++i)                                           // Комментарий: заполняем массив
        a[i] = dis(gen);                                                  // Комментарий: присваиваем случайное значение
    return a;                                                             // Комментарий: возвращаем массив
}                                                                         // Комментарий: конец функции

// -------------------- Замер времени в миллисекундах --------------------     // Комментарий: секция тайминга
template <typename Func>                                                  // Комментарий: шаблон для замера любой функции сортировки
static long long time_ms(Func f, vector<int> a)                           // Комментарий: принимаем функцию и копию массива
{                                                                         // Комментарий: начало функции
    volatile int warm = 0;                                                // Комментарий: прогрев, чтобы уменьшить шум от кэшей/первого запуска
    for (int i = 0; i < (int)a.size(); ++i) warm += a[i];                 // Комментарий: “трогаем” данные

    auto t1 = high_resolution_clock::now();                               // Комментарий: старт таймера
    f(a);                                                                 // Комментарий: запускаем сортировку
    auto t2 = high_resolution_clock::now();                               // Комментарий: конец таймера

    if (!is_sorted(a.begin(), a.end()))                                   // Комментарий: проверяем корректность сортировки
        cerr << "Sort error!\n";                                          // Комментарий: если не отсортировано — сообщаем

    return duration_cast<milliseconds>(t2 - t1).count();                  // Комментарий: возвращаем время в миллисекундах
}                                                                         // Комментарий: конец функции

// -------------------- Прогон для одного размера --------------------         // Комментарий: секция запуска
static void run_case(int n)                                               // Комментарий: запускает замеры для размера n
{                                                                         // Комментарий: начало функции
    vector<int> base = make_random_array(n, 12345);                       // Комментарий: исходные данные (одинаковые для seq/omp)

    long long t_seq = time_ms(                                            // Комментарий: замеряем seq
        [](vector<int>& x) { selection_sort_seq(x); },                    // Комментарий: передаём seq сортировку
        base                                                             // Комментарий: массив-основа
    );                                                                    // Комментарий: конец вызова

    long long t_par = time_ms(                                            // Комментарий: замеряем omp
        [](vector<int>& x) { selection_sort_omp(x); },                    // Комментарий: передаём omp сортировку
        base                                                             // Комментарий: массив-основа
    );                                                                    // Комментарий: конец вызова

    cout << "Array size: " << n << "\n";                                  // Комментарий: формат вывода как в примере
    cout << "Sequential time: " << t_seq << " ms\n";                      // Комментарий: время последовательной версии
    cout << "Parallel time: " << t_par << " ms\n\n";                      // Комментарий: время параллельной версии + пустая строка
}                                                                         // Комментарий: конец функции

int main()                                                                // Комментарий: main
{                                                                         // Комментарий: начало main
    run_case(1000);                                                       // Комментарий: прогон для 1000
    run_case(10000);                                                      // Комментарий: прогон для 10000
    return 0;                                                             // Комментарий: успешное завершение
}                                                                         // Комментарий: конец main
