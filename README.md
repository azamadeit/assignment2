# Assignment2

## Задача №1
**Гетерогенная параллелизация** — это подход, когда в одной задаче одновременно (или по этапам) используются разные вычислительные устройства с разной архитектурой, чаще всего CPU + GPU (иногда ещё FPGA/TPU). Идея: отдать CPU то, где важна сложная логика и ветвления, а GPU — массовые однотипные вычисления над большими данными.

### 1) Различия параллельных вычислений на CPU и GPU

CPU: мало “тяжёлых” ядер, сильные ядра, большие кэши, хорошо переносит ветвления, рекурсию, сложные структуры данных. Подходит для “разных” задач, где потоки выполняют разные ветки кода.

GPU: очень много “легких” ядер/потоков, упор в пропускную способность, выигрывает на одинаковых операциях над массивами. Плохо переносит сильную дивергенцию ветвлений (когда разные потоки идут по разным if), любит “плотную” математику и регулярный доступ к памяти.

### 2) Преимущества гетерогенной параллелизации

- Скорость: тяжёлые массовые этапы (фильтры, матрицы, свёртки, сортировки/редукции) уезжают на GPU.

- Энергоэффективность: GPU часто даёт больше операций на ватт для data-parallel задач.

- Гибкость: CPU управляет, готовит данные, решает нерегулярные части, GPU “молотит” регулярные.

### 3) Примеры реальных приложений

#### Машинное обучение (CPU+GPU)
- PyTorch
- TensorFlow
- JAX
- XGBoost (есть GPU-ускорение)
- LightGBM (есть GPU-ускорение)
- ONNX Runtime (поддерживает разные аппаратные бэкенды)

#### Научные расчёты / симуляции (HPC)
- GROMACS (молекулярная динамика, активно использует GPU)
- LAMMPS (молекулярная динамика, есть GPU-пакеты)
- NAMD (молекулярная динамика, GPU-ускорение)
- AMBER (MD, GPU-ускорение)
- OpenFOAM (CFD; часто CPU, но есть GPU-направления/сборки и гетерогенные пайплайны в проектах вокруг него)
- ANSYS Fluent (коммерческий CFD, поддержка GPU для ряда задач/солверов)
- COMSOL Multiphysics (в ряде конфигураций/лицензий — ускорение через GPU/акселераторы)
- LS-DYNA (явная динамика, есть GPU-опции)
- VASP (квантово-химические расчёты; есть версии/сборки с GPU-ускорением в HPC-практике)

#### Рендеринг / графика / 3D
- Blender (Cycles рендер на GPU, сцена/логика на CPU)
- Autodesk Arnold (есть GPU-рендер)
- V-Ray (GPU-рендер)
- OctaneRender (GPU-рендер)

#### Видео/изображения (медиа-пайплайны CPU+GPU)
- FFmpeg (через NVENC/NVDEC, CUDA-фильтры, VAAPI/Quick Sync — типичный гетерогенный пайплайн)
- DaVinci Resolve (массово грузит GPU: цвет, эффекты, AI-инструменты)
- Adobe Premiere Pro (GPU-ускорение эффектов/кодирования)
- Adobe After Effects (часть эффектов/рендера с GPU)
- Adobe Photoshop (GPU для фильтров/нейрофункций)

#### Компьютерное зрение / робототехника
- OpenCV (CUDA/OpenCL-модули)
- NVIDIA DeepStream (видеoаналитика: декод на GPU + инференс на GPU, управление на CPU)

#### Базы/аналитика/Big Data (часто CPU+GPU)
- RAPIDS (cuDF, cuML, cuGraph — GPU-аналитика, orchestration на CPU)
- Apache Spark с NVIDIA RAPIDS Accelerator for Apache Spark (Spark-пайплайн + GPU-ускорение)

--------------------------------------------------------------------------------------------------
## Задача №2
Создание массива, содержащего 10 000 случайных чисел.
Определение минимального и максимального элементов:
- последовательным методом;
- параллельным методом с применением OpenMP.

Сравнение времени выполнения последовательной и параллельной реализаций.

Вывод:

```
Array size: 1000     
Sequential time: 6 ms
Parallel time: 4 ms  

Array size: 10000      
Sequential time: 603 ms
Parallel time: 359 ms  
```
